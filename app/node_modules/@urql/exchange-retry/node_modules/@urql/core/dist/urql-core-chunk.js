var graphql = require('graphql');
var wonka = require('wonka');
var generateErrorMessage = (networkErr, graphQlErrs) => {
  var error = '';
  if (networkErr) return `[Network] ${networkErr.message}`;
  if (graphQlErrs) {
    for (var err of graphQlErrs) {
      if (error) error += '\n';
      error += `[GraphQL] ${err.message}`;
    }
  }
  return error;
};
var rehydrateGraphQlError = error => {
  if (error instanceof graphql.GraphQLError) {
    return error;
  } else if (typeof error === 'object' && error.message) {
    return new graphql.GraphQLError(error.message, error.nodes, error.source, error.positions, error.path, error, error.extensions || {});
  } else {
    return new graphql.GraphQLError(error);
  }
};
/** An abstracted `Error` that provides either a `networkError` or `graphQLErrors`.
 *
 * @remarks
 * During a GraphQL request, either the request can fail entirely, causing a network error,
 * or the GraphQL execution or fields can fail, which will cause an {@link ExecutionResult}
 * to contain an array of GraphQL errors.
 *
 * The `CombinedError` abstracts and normalizes both failure cases. When {@link OperationResult.error}
 * is set to this error, the `CombinedError` abstracts all errors, making it easier to handle only
 * a subset of error cases.
 *
 * @see {@link https://formidable.com/open-source/urql/docs/basics/errors/} for more information on handling
 * GraphQL errors and the `CombinedError`.
 */
class CombinedError extends Error {
  /** A list of GraphQL errors rehydrated from a {@link ExecutionResult}.
   *
   * @remarks
   * If an {@link ExecutionResult} received from the API contains a list of errors,
   * the `CombinedError` will rehydrate them, normalize them to
   * {@link GraphQLError | GraphQLErrors} and list them here.
   * An empty list indicates that no GraphQL error has been sent by the API.
   */

  /** Set to an error, if a GraphQL request has failed outright.
   *
   * @remarks
   * A GraphQL over HTTP request may fail and not reach the API. Any error that
   * prevents a GraphQl request outright, will be considered a “network error” and
   * set here.
   */

  /** Set to the {@link Response} object a fetch exchange received.
   *
   * @remarks
   * If a built-in fetch {@link Exchange} is used in `urql`, this may
   * be set to the {@link Response} object of the Fetch API response.
   * However, since `urql` doesn’t assume that all users will use HTTP
   * as the only or exclusive transport for GraphQL this property is
   * neither typed nor guaranteed and may be re-used for other purposes
   * by non-fetch exchanges.
   *
   * Hint: It can be useful to use `response.status` here, however, if
   * you plan on relying on this being a {@link Response} in your app,
   * which it is by default, then make sure you add some extra checks
   * before blindly assuming so!
   */

  constructor(input) {
    var normalizedGraphQLErrors = (input.graphQLErrors || []).map(rehydrateGraphQlError);
    var message = generateErrorMessage(input.networkError, normalizedGraphQLErrors);
    super(message);
    this.name = 'CombinedError';
    this.message = message;
    this.graphQLErrors = normalizedGraphQLErrors;
    this.networkError = input.networkError;
    this.response = input.response;
  }
  toString() {
    return this.message;
  }
}

/** Computes a djb2 hash of the given string.
 *
 * @param x - the string to be hashed
 * @param seed - optionally a prior hash for progressive hashing
 * @returns a hash value, i.e. a number
 *
 * @remark
 * This is the hashing function used throughout `urql`, primarily to compute
 * {@link Operation.key}.
 *
 * @see {@link http://www.cse.yorku.ca/~oz/hash.html#djb2} for a further description of djb2.
 */
var phash = (x, seed) => {
  var h = typeof seed === 'number' ? seed | 0 : 5381;
  for (var i = 0, l = x.length | 0; i < l; i++) {
    h = (h << 5) + h + x.charCodeAt(i);
  }
  return h;
};
var seen = new Set();
var cache = new WeakMap();
var stringify = x => {
  if (x === null || seen.has(x)) {
    return 'null';
  } else if (typeof x !== 'object') {
    return JSON.stringify(x) || '';
  } else if (x.toJSON) {
    return stringify(x.toJSON());
  } else if (Array.isArray(x)) {
    var _out = '[';
    for (var value of x) {
      if (_out !== '[') _out += ',';
      value = stringify(value);
      _out += value.length > 0 ? value : 'null';
    }
    _out += ']';
    return _out;
  }
  var keys = Object.keys(x).sort();
  if (!keys.length && x.constructor && x.constructor !== Object) {
    var key = cache.get(x) || Math.random().toString(36).slice(2);
    cache.set(x, key);
    return `{"__key":"${key}"}`;
  }
  seen.add(x);
  var out = '{';
  for (var _key of keys) {
    var _value = stringify(x[_key]);
    if (_value) {
      if (out.length > 1) out += ',';
      out += stringify(_key) + ':' + _value;
    }
  }
  seen.delete(x);
  out += '}';
  return out;
};
/** A stable stringifier for GraphQL variables objects.
 *
 * @param x - any JSON-like data.
 * @return A JSON string.
 *
 * @remarks
 * This utility creates a stable JSON string from any passed data,
 * and protects itself from throwing.
 *
 * The JSON string is stable insofar as objects’ keys are sorted,
 * and instances of non-plain objects are replaced with random keys
 * replacing their values, which remain stable for the objects’
 * instance.
 */
var stringifyVariables = x => {
  seen.clear();
  return stringify(x);
};
var SOURCE_NAME = 'gql';
var GRAPHQL_STRING_RE = /("{3}[\s\S]*"{3}|"(?:\\.|[^"])*")/g;
var REPLACE_CHAR_RE = /(#[^\n\r]+)?(?:\n|\r\n?|$)+/g;
var replaceOutsideStrings = (str, idx) => idx % 2 === 0 ? str.replace(REPLACE_CHAR_RE, '\n') : str;
/** Sanitizes a GraphQL document string by replacing comments and redundant newlines in it. */
var sanitizeDocument = node => node.split(GRAPHQL_STRING_RE).map(replaceOutsideStrings).join('').trim();
var prints = new Map();
var docs = new Map();
/** A cached printing function for GraphQL documents.
 *
 * @param node - A string of a document or a {@link DocumentNode}
 * @returns A normalized printed string of the passed GraphQL document.
 *
 * @remarks
 * This function accepts a GraphQL query string or {@link DocumentNode},
 * then prints and sanitizes it. The sanitizer takes care of removing
 * comments, which otherwise alter the key of the document although the
 * document is otherwise equivalent to another.
 *
 * When a {@link DocumentNode} is passed to this function, it caches its
 * output by modifying the `loc.source.body` property on the GraphQL node.
 */
var stringifyDocument = node => {
  var printed;
  if (typeof node === 'string') {
    printed = sanitizeDocument(node);
  } else if (node.loc && docs.get(node.__key) === node) {
    printed = node.loc.source.body;
  } else {
    printed = prints.get(node) || sanitizeDocument(graphql.print(node));
    prints.set(node, printed);
  }
  if (typeof node !== 'string' && !node.loc) {
    node.loc = {
      start: 0,
      end: printed.length,
      source: {
        body: printed,
        name: SOURCE_NAME,
        locationOffset: {
          line: 1,
          column: 1
        }
      }
    };
  }
  return printed;
};
/** Computes the hash for a document's string using {@link stringifyDocument}'s output.
 *
 * @param node - A string of a document or a {@link DocumentNode}
 * @returns A {@link HashValue}
 *
 * @privateRemarks
 * This function adds the operation name of the document to the hash, since sometimes
 * a merged document with multiple operations may be used. Although `urql` requires a
 * `DocumentNode` to only contain a single operation, when the cached `loc.source.body`
 * of a `DocumentNode` is used, this string may still contain multiple operations and
 * the resulting hash should account for only one at a time.
 */
var hashDocument = node => {
  var key = phash(stringifyDocument(node));
  // Add the operation name to the produced hash
  if (typeof node === 'object' && 'definitions' in node) {
    var operationName = getOperationName(node);
    if (operationName) key = phash(`\n# ${operationName}`, key);
  }
  return key;
};
/** Returns a canonical version of the passed `DocumentNode` with an added hash key.
 *
 * @param node - A string of a document or a {@link DocumentNode}
 * @returns A {@link KeyedDocumentNode}
 *
 * @remarks
 * `urql` will always avoid unnecessary work, no matter whether a user passes `DocumentNode`s
 * or strings of GraphQL documents to its APIs.
 *
 * This function will return a canonical version of a {@link KeyedDocumentNode} no matter
 * which kind of input is passed, avoiding parsing or hashing of passed data as needed.
 */
var keyDocument = node => {
  var key;
  var query;
  if (typeof node === 'string') {
    key = hashDocument(node);
    query = docs.get(key) || graphql.parse(node, {
      noLocation: true
    });
  } else {
    key = node.__key || hashDocument(node);
    query = docs.get(key) || node;
  }
  // Add location information if it's missing
  if (!query.loc) stringifyDocument(query);
  query.__key = key;
  docs.set(key, query);
  return query;
};
/** Creates a `GraphQLRequest` from the passed parameters.
 *
 * @param q - A string of a document or a {@link DocumentNode}
 * @param variables - A variables object for the defined GraphQL operation.
 * @returns A {@link GraphQLRequest}
 *
 * @remarks
 * `createRequest` creates a {@link GraphQLRequest} from the passed parameters,
 * while replacing the document as needed with a canonical version of itself,
 * to avoid parsing, printing, or hashing the same input multiple times.
 *
 * If no variables are passed, canonically it'll default to an empty object,
 * which is removed from the resulting hash key.
 */
var createRequest = (q, variables) => {
  if (!variables) variables = {};
  var query = keyDocument(q);
  var printedVars = stringifyVariables(variables);
  var key = query.__key;
  if (printedVars !== '{}') key = phash(printedVars, key);
  return {
    key,
    query,
    variables
  };
};
/** Returns the name of the `DocumentNode`'s operation, if any.
 * @param query - A {@link DocumentNode}
 * @returns the operation's name contained within the document, or `undefined`
 */
var getOperationName = query => {
  for (var node of query.definitions) {
    if (node.kind === graphql.Kind.OPERATION_DEFINITION && node.name) {
      return node.name.value;
    }
  }
};
/** Returns the type of the `DocumentNode`'s operation, if any.
 * @param query - A {@link DocumentNode}
 * @returns the operation's type contained within the document, or `undefined`
 */
var getOperationType = query => {
  for (var node of query.definitions) {
    if (node.kind === graphql.Kind.OPERATION_DEFINITION) {
      return node.operation;
    }
  }
};

/** Converts the `ExecutionResult` received for a given `Operation` to an `OperationResult`.
 *
 * @param operation - The {@link Operation} for which the API’s result is for.
 * @param result - The GraphQL API’s {@link ExecutionResult}.
 * @param response - Optionally, a raw object representing the API’s result (Typically a {@link Response}).
 * @returns An {@link OperationResult}.
 *
 * @remarks
 * This utility can be used to create {@link OperationResult | OperationResults} in the shape
 * that `urql` expects and defines, and should be used rather than creating the results manually.
 *
 * @throws
 * If no data, or errors are contained within the result, or the result is instead an incremental
 * response containing a `path` property, a “No Content” error is thrown.
 *
 * @see {@link ExecutionResult} for the type definition of GraphQL API results.
 */
var makeResult = (operation, result, response) => {
  if (!('data' in result) && !('errors' in result) || 'incremental' in result) {
    throw new Error('No Content');
  }
  var defaultHasNext = operation.kind === 'subscription';
  return {
    operation,
    data: result.data,
    error: Array.isArray(result.errors) ? new CombinedError({
      graphQLErrors: result.errors,
      response
    }) : undefined,
    extensions: typeof result.extensions === 'object' && result.extensions || undefined,
    hasNext: result.hasNext == null ? defaultHasNext : result.hasNext
  };
};
/** Merges an incrementally delivered `ExecutionResult` into a previous `OperationResult`.
 *
 * @param prevResult - The {@link OperationResult} that preceded this result.
 * @param path - The GraphQL API’s {@link ExecutionResult} that should be patching the `prevResult`.
 * @param response - Optionally, a raw object representing the API’s result (Typically a {@link Response}).
 * @returns A new {@link OperationResult} patched with the incremental result.
 *
 * @remarks
 * This utility should be used to merge subsequent {@link ExecutionResult | ExecutionResults} of
 * incremental responses into a prior {@link OperationResult}.
 *
 * When directives like `@defer`, `@stream`, and `@live` are used, GraphQL may deliver new
 * results that modify previous results. In these cases, it'll set a `path` property to modify
 * the result it sent last. This utility is built to handle these cases and merge these payloads
 * into existing {@link OperationResult | OperationResults}.
 *
 * @see {@link ExecutionResult} for the type definition of GraphQL API results.
 */
var mergeResultPatch = (prevResult, nextResult, response) => {
  var data;
  var hasExtensions = !!prevResult.extensions || !!nextResult.extensions;
  var extensions = {
    ...prevResult.extensions,
    ...nextResult.extensions
  };
  var errors = prevResult.error ? prevResult.error.graphQLErrors : [];
  var incremental = nextResult.incremental;
  // NOTE: We handle the old version of the incremental delivery payloads as well
  if ('path' in nextResult) {
    incremental = [{
      data: nextResult.data,
      path: nextResult.path
    }];
  }
  if (incremental) {
    data = {
      ...prevResult.data
    };
    for (var patch of incremental) {
      if (Array.isArray(patch.errors)) {
        errors.push(...patch.errors);
      }
      if (patch.extensions) {
        Object.assign(extensions, patch.extensions);
        hasExtensions = true;
      }
      var prop = patch.path[0];
      var part = data;
      for (var i = 1, l = patch.path.length; i < l; prop = patch.path[i++]) {
        part = part[prop] = Array.isArray(part[prop]) ? [...part[prop]] : {
          ...part[prop]
        };
      }
      if (Array.isArray(patch.items)) {
        var startIndex = +prop >= 0 ? prop : 0;
        for (var _i = 0, _l = patch.items.length; _i < _l; _i++) {
          part[startIndex + _i] = patch.items[_i];
        }
      } else if (patch.data !== undefined) {
        part[prop] = part[prop] && patch.data ? {
          ...part[prop],
          ...patch.data
        } : patch.data;
      }
    }
  } else {
    data = nextResult.data || prevResult.data;
  }
  return {
    operation: prevResult.operation,
    data,
    error: errors.length ? new CombinedError({
      graphQLErrors: errors,
      response
    }) : undefined,
    extensions: hasExtensions ? extensions : undefined,
    hasNext: !!nextResult.hasNext
  };
};
/** Creates an `OperationResult` containing a network error for requests that encountered unexpected errors.
 *
 * @param operation - The {@link Operation} for which the API’s result is for.
 * @param error - The network-like error that prevented an API result from being delivered.
 * @param response - Optionally, a raw object representing the API’s result (Typically a {@link Response}).
 * @returns An {@link OperationResult} containing only a {@link CombinedError}.
 *
 * @remarks
 * This utility can be used to create {@link OperationResult | OperationResults} in the shape
 * that `urql` expects and defines, and should be used rather than creating the results manually.
 * This function should be used for when the {@link CombinedError.networkError} property is
 * populated and no GraphQL execution actually occurred.
 */
var makeErrorResult = (operation, error, response) => ({
  operation,
  data: undefined,
  error: new CombinedError({
    networkError: error,
    response
  }),
  extensions: undefined
});

/** Creates a GraphQL over HTTP compliant JSON request body.
 * @param request - An object containing a `query` document and `variables`.
 * @returns A {@link FetchBody}
 * @see {@link https://github.com/graphql/graphql-over-http} for the GraphQL over HTTP spec.
 */
function makeFetchBody(request) {
  return {
    query: stringifyDocument(request.query),
    operationName: getOperationName(request.query),
    variables: request.variables || undefined,
    extensions: undefined
  };
}
/** Creates a URL that will be called for a GraphQL HTTP request.
 *
 * @param operation - An {@link Operation} for which to make the request.
 * @param body - A {@link FetchBody} which may be replaced with a URL.
 *
 * @remarks
 * Creates the URL that’ll be called as part of a GraphQL HTTP request.
 * Built-in fetch exchanges support sending GET requests, even for
 * non-persisted full requests, which this function supports by being
 * able to serialize GraphQL requests into the URL.
 */
var makeFetchURL = (operation, body) => {
  var useGETMethod = operation.kind === 'query' && operation.context.preferGetMethod;
  if (!useGETMethod || !body) return operation.context.url;
  var url = new URL(operation.context.url);
  var search = url.searchParams;
  if (body.operationName) search.set('operationName', body.operationName);
  if (body.query) search.set('query', body.query);
  if (body.variables) search.set('variables', stringifyVariables(body.variables));
  if (body.extensions) search.set('extensions', stringifyVariables(body.extensions));
  var finalUrl = url.toString();
  if (finalUrl.length > 2047 && useGETMethod !== 'force') {
    operation.context.preferGetMethod = false;
    return operation.context.url;
  }
  return finalUrl;
};
/** Creates a `RequestInit` object for a given `Operation`.
 *
 * @param operation - An {@link Operation} for which to make the request.
 * @param body - A {@link FetchBody} which is added to the options, if the request isn’t a GET request.
 *
 * @remarks
 * Creates the fetch options {@link RequestInit} object that’ll be passed to the Fetch API
 * as part of a GraphQL over HTTP request. It automatically sets a default `Content-Type`
 * header.
 *
 * @see {@link https://github.com/graphql/graphql-over-http} for the GraphQL over HTTP spec.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API} for the Fetch API spec.
 */
var makeFetchOptions = (operation, body) => {
  var useGETMethod = operation.kind === 'query' && !!operation.context.preferGetMethod;
  var headers = {
    accept: 'multipart/mixed, application/graphql-response+json, application/graphql+json, application/json'
  };
  if (!useGETMethod) headers['content-type'] = 'application/json';
  var extraOptions = (typeof operation.context.fetchOptions === 'function' ? operation.context.fetchOptions() : operation.context.fetchOptions) || {};
  if (extraOptions.headers) for (var key in extraOptions.headers) {
    headers[key.toLowerCase()] = extraOptions.headers[key];
  }
  return {
    ...extraOptions,
    body: !useGETMethod && body ? JSON.stringify(body) : undefined,
    method: useGETMethod ? 'GET' : 'POST',
    headers
  };
};
var decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder() : null;
var jsonHeaderRe = /content-type:[^\r\n]*application\/json/i;
var boundaryHeaderRe = /boundary="?([^=";]+)"?/i;
// NOTE: We're avoiding referencing the `Buffer` global here to prevent
// auto-polyfilling in Webpack
var toString = input => input.constructor.name === 'Buffer' ? input.toString() : decoder.decode(input);
/** Makes a GraphQL HTTP request to a given API by wrapping around the Fetch API.
 *
 * @param operation - The {@link Operation} that should be sent via GraphQL over HTTP.
 * @param url - The endpoint URL for the GraphQL HTTP API.
 * @param fetchOptions - The {@link RequestInit} fetch options for the request.
 * @returns A Wonka {@link Source} of {@link OperationResult | OperationResults}.
 *
 * @remarks
 * This utility defines how all built-in fetch exchanges make GraphQL HTTP requests,
 * supporting multipart incremental responses, cancellation and other smaller
 * implementation details.
 *
 * If you’re implementing a modified fetch exchange for a GraphQL over HTTP API
 * it’s recommended you use this utility.
 *
 * Hint: This function does not use the passed `operation` to create or modify the
 * `fetchOptions` and instead expects that the options have already been created
 * using {@link makeFetchOptions} and modified as needed.
 *
 * @throws
 * If the `fetch` polyfill or globally available `fetch` function doesn’t support
 * streamed multipart responses while trying to handle a `multipart/mixed` GraphQL response,
 * the source will throw “Streaming requests unsupported”.
 * This shouldn’t happen in modern browsers and Node.js.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API} for the Fetch API spec.
 */
var makeFetchSource = (operation, url, fetchOptions) => {
  var maxStatus = fetchOptions.redirect === 'manual' ? 400 : 300;
  var fetcher = operation.context.fetch;
  return wonka.make(({
    next,
    complete
  }) => {
    var abortController = typeof AbortController !== 'undefined' ? new AbortController() : null;
    if (abortController) {
      fetchOptions.signal = abortController.signal;
    }
    var hasResults = false;
    // DERIVATIVE: Copyright (c) 2021 Marais Rossouw <hi@marais.io>
    // See: https://github.com/maraisr/meros/blob/219fe95/src/browser.ts
    var executeIncrementalFetch = (onResult, operation, response) => {
      // NOTE: Guarding against fetch polyfills here
      var contentType = response.headers && response.headers.get('Content-Type') || '';
      if (/text\//i.test(contentType)) {
        return response.text().then(text => {
          onResult(makeErrorResult(operation, new Error(text), response));
        });
      } else if (!/multipart\/mixed/i.test(contentType)) {
        return response.text().then(payload => {
          onResult(makeResult(operation, JSON.parse(payload), response));
        });
      }
      var boundary = '---';
      var boundaryHeader = contentType.match(boundaryHeaderRe);
      if (boundaryHeader) boundary = '--' + boundaryHeader[1];
      var read;
      var cancel = () => {
        /*noop*/
      };
      if (response[Symbol.asyncIterator]) {
        var iterator = response[Symbol.asyncIterator]();
        read = iterator.next.bind(iterator);
      } else if ('body' in response && response.body) {
        var reader = response.body.getReader();
        cancel = () => reader.cancel();
        read = () => reader.read();
      } else {
        throw new TypeError('Streaming requests unsupported');
      }
      var buffer = '';
      var isPreamble = true;
      var nextResult = null;
      var prevResult = null;
      function next(data) {
        if (!data.done) {
          var chunk = toString(data.value);
          var boundaryIndex = chunk.indexOf(boundary);
          if (boundaryIndex > -1) {
            boundaryIndex += buffer.length;
          } else {
            boundaryIndex = buffer.indexOf(boundary);
          }
          buffer += chunk;
          while (boundaryIndex > -1) {
            var current = buffer.slice(0, boundaryIndex);
            var _next = buffer.slice(boundaryIndex + boundary.length);
            if (isPreamble) {
              isPreamble = false;
            } else {
              var headersEnd = current.indexOf('\r\n\r\n') + 4;
              var headers = current.slice(0, headersEnd);
              var body = current.slice(headersEnd, current.lastIndexOf('\r\n'));
              var payload = void 0;
              if (jsonHeaderRe.test(headers)) {
                try {
                  payload = JSON.parse(body);
                  nextResult = prevResult = prevResult ? mergeResultPatch(prevResult, payload, response) : makeResult(operation, payload, response);
                } catch (_error) {}
              }
              if (_next.slice(0, 2) === '--' || payload && !payload.hasNext) {
                if (!prevResult) return onResult(makeResult(operation, {}, response));
                break;
              }
            }
            buffer = _next;
            boundaryIndex = buffer.indexOf(boundary);
          }
        } else {
          hasResults = true;
        }
        if (nextResult) {
          onResult(nextResult);
          nextResult = null;
        }
        if (!data.done && (!prevResult || prevResult.hasNext)) {
          return read().then(next);
        }
      }
      return read().then(next).finally(cancel);
    };
    var ended = false;
    var statusNotOk = false;
    var response;
    Promise.resolve().then(() => {
      if (ended) return;
      return (fetcher || fetch)(url, fetchOptions);
    }).then(_response => {
      if (!_response) return;
      response = _response;
      statusNotOk = response.status < 200 || response.status >= maxStatus;
      return executeIncrementalFetch(next, operation, response);
    }).then(complete).catch(error => {
      if (hasResults) {
        throw error;
      }
      var result = makeErrorResult(operation, statusNotOk ? response.statusText ? new Error(response.statusText) : error : error, response);
      next(result);
      complete();
    });
    return () => {
      ended = true;
      if (abortController) {
        abortController.abort();
      }
    };
  });
};
exports.CombinedError = CombinedError;
exports.createRequest = createRequest;
exports.getOperationName = getOperationName;
exports.getOperationType = getOperationType;
exports.keyDocument = keyDocument;
exports.makeErrorResult = makeErrorResult;
exports.makeFetchBody = makeFetchBody;
exports.makeFetchOptions = makeFetchOptions;
exports.makeFetchSource = makeFetchSource;
exports.makeFetchURL = makeFetchURL;
exports.makeResult = makeResult;
exports.mergeResultPatch = mergeResultPatch;
exports.stringifyDocument = stringifyDocument;
exports.stringifyVariables = stringifyVariables;
//# sourceMappingURL=urql-core-chunk.js.map
